# 레시피 재료 파싱 문제 분석 및 해결 방안

## 1. 문제 현황

현재 외부 API (특히, 식품안전나라)로부터 레시피 정보를 가져올 때, 재료(ingredient) 정보가 올바르게 파싱되지 않는 문제가 발생하고 있습니다.

### 문제 사례

- **사례 1: `닭고기(가슴살, 25g)`**
    - API 제공: `닭고기(가슴살, 25g)`
    - 현재 파싱 결과 (추정): 이름: `닭고기(가슴살`, 양: `25g)` -> 부정확
- **사례 2: `고추잡채`의 재료**
    - API 제공: `... 식용유 5g[소스소개] 고기 밑간 양념:후춧가루 0.1g ...`
    - 현재 파싱 결과 (추정): `식용유`와 `고기 밑간 양념` 등이 별개의 재료처럼 분리되거나, `[소스소개]`와 같은 특수 구문 처리 불가
- **사례 3: `감자냉채`의 재료**
    - API 제공: `... 오이 10g [소스소개 단촛물:물60g, 식초 1.5g, ...] ...`
    - 현재 파싱 결과 (추정): `단촛물`의 상세 내용이 쉼표(`,`)로 인해 여러 개의 망가진 재료 정보로 분리됨

## 2. 추가 문제 사례 (2025-11-10 분석)

사용자가 제공한 추가 예시를 통해 식품안전나라 API의 `RCP_PARTS_DTLS` 필드가 매우 비정형적이며, 다양한 패턴을 포함하고 있음을 확인했습니다.

- **줄바꿈 (`\n`)**: `대구지리탕`의 예시처럼 쉼표가 아닌 줄바꿈으로 재료가 구분됩니다.
    - `쑥갓(10g)\n반죽 쑥가루(10g)`
- **HTML 태그 (`<br>`)**: `소고기 김말이` 예시처럼 `<br>` 태그가 포함되어 있습니다.
    - `1인분 기준<br>[주재료] 소고기(치맛살)(100g)`
- **다양한 구분자 및 섹션 마커**: 재료와 양념을 구분하기 위해 일관성 없는 마커가 사용됩니다.
    - `[양념장]`, `[소스소개]`, `[주재료]`
    - `•소스`, `●주재료`, `●장식`
    - `- 양념장 :`, `비빔장 :`
    - `고기양념(5인분):`
- **복합 패턴**: 여러 패턴이 한 줄에 동시에 나타납니다.
    - `통깨(5g)\n- 양념장 : 고춧가루(20g)`
    - `식용유(3g)\n•소스 : 맛간장(5g)`
    - `마늘다진것 1g[소스1]간장 1g`
- **불완전한 데이터**: 하나의 재료 정보가 여러 줄에 걸쳐 나뉘어 있기도 합니다.
    - `두가지 묵(올방개묵` -> 다음 줄에 `검정깨묵) 각`

이러한 복잡성으로 인해 단순한 쉼표 기반 파싱 로직은 실패할 수밖에 없습니다.

## 3. 해결 방안

### 1단계: 파싱 로직 대대적 수정 (서버 측)

API 응답의 비정형성을 해결하기 위해, `RecipeMapper.java`의 `parseIngredients` 메서드를 여러 단계를 거치는 정교한 파싱 전략을 도입하여 전면 재작성합니다. 이는 부정확한 파싱을 최소화하여 사용자가 직접 수정해야 하는 번거로움을 줄이는 것을 목표로 합니다.

1.  **전처리 (Normalization)**:
    - `rcpPartsDtls` 문자열을 받으면, 파싱을 방해하는 요소들을 일관된 형태로 정리합니다.
    - HTML 태그 (`<br>`)를 줄바꿈(`\n`)으로 변경합니다.
    - 다양한 섹션 마커 (`[소스]`, `●양념`, `•재료` 등)를 줄바꿈으로 변환하여 재료 목록을 분리할 준비를 합니다.

2.  **1차 분리 (Line-based Splitting)**:
    - 쉼표 대신 **줄바꿈(`\n`)**을 기준으로 문자열을 1차 분리하여 각 재료 라인을 얻습니다.

3.  **2차 분리 (Comma-based Splitting)**:
    - 1차 분리된 각 라인에 여전히 여러 재료가 포함된 경우, **괄호 바깥의 쉼표**만을 기준으로 2차 분리를 수행합니다.

4.  **재료/용량 추출 (Pattern Matching)**:
    - 최종 분리된 각 재료 문자열에 대해, 아래 패턴들을 순차적으로 적용하여 이름과 용량을 정교하게 추출합니다.
        - **패턴 1**: `이름 (용량)` -> e.g., `닭고기 (가슴살, 25g)`
        - **패턴 2**: `이름 용량` -> e.g., `돼지고기 30g`
        - **패턴 3**: `이름` (용량 없음) -> e.g., `죽순통조림`
    - 파싱 실패 시, 해당 문자열 전체를 `이름`으로, `용량`은 "적당량"으로 지정하여 데이터 유실을 최소화합니다.

### 2단계: 사용자 직접 수정 기능 구현 (클라이언트 측)

1단계의 파싱 개선으로도 완벽하게 처리되지 않는 경우를 대비하여, 사용자가 공동구매 생성 페이지에서 직접 재료를 수정할 수 있는 기능을 제공합니다.

**분석 결과:**
- 코드베이스 분석 결과, 이 기능은 **프론트엔드 수정만으로 구현 가능**합니다.
- 백엔드(`GroupBuyController`, `CreateGroupBuyRequest` DTO)는 이미 수정된 재료명과 용량을 JSON 형태로 받아 처리할 수 있도록 설계되어 있습니다.

**구현 계획:**
- **대상 파일**: `src/main/resources/templates/group-purchases/form.html`
- **수정 내용**:
    1.  **재료명 입력 필드 변경**: 현재 재료명이 `<span>` 또는 `<label>`과 같은 정적 텍스트로 표시되는 부분을 `<input type="text">`로 변경합니다.
        - 이 입력 필드는 `th:value`를 사용하여 기존 재료명으로 미리 채워집니다.
    2.  **JavaScript 로직 수정**:
        - 공동구매 생성을 위해 제출 버튼을 누를 때 동작하는 JavaScript 스크립트를 수정합니다.
        - 기존에는 `data-name` 속성에서 재료명을 읽었지만, 이제 새로 추가된 `<input>` 필드의 `value`에서 재료명을 읽어오도록 변경합니다.
        - 재료 용량은 이미 `<input>` 필드로 되어 있으므로 기존 로직을 그대로 사용합니다.

### 3단계: 장기적 개선

- **사용자 경험 고도화**: 재료 수정 UI를 보다 직관적으로 개선하거나, 자주 수정되는 패턴을 분석하여 파싱 로직을 지속적으로 고도화할 수 있습니다.

## 4. 예상 결과

- **1단계 (파서 개선)**: 서버 측에서 파싱 정확도를 높여, 사용자가 보게 될 초기 재료 데이터의 품질이 크게 향상됩니다.
- **2단계 (UI 수정)**: 파싱이 여전히 불완전하더라도, 사용자가 공동구매 생성 과정에서 직접 재료명과 용량을 손쉽게 수정할 수 있게 되어 데이터의 최종 정확성을 보장하고 사용자 편의성을 높입니다.
- 두 단계가 결합되어, 비정형적인 API 데이터 문제에 대해 견고하고 사용자 친화적인 해결책을 제공할 수 있습니다.
